#!/usr/bin/env node

var path = require('path');

var fs = require('fs'),
  program = require('commander'),
  _ = require('lodash'),
  dox = require('dox'),
  md = require('github-flavored-markdown').parse,
  fs = require('fs');

program
  .usage('simple-doc [options] <files>')
  .option('-o, --output [file]', 'Output file. Defaults to stdout', false)
  .option('-t, --title [title: Docs]', 'Title for document', 'Docs')
  .option('-n, --nolink [false]', 'Don\'t link back to the top', false)
  .option('--html [false]', 'Output html instead of markdown', false)
  .parse(process.argv)

function generateOutput(files) {
  var output = '';

  files.forEach(function(file) {
    // Generate a list of prototypes and methods attached to those prototypes
    file.contents.protos.forEach(function(proto) {
      output += '* ' + linkify(proto.name) + ' (' + file.name + ')' + '\n';
      output += proto.methods.map(function(method) {
        return '    * ' + 
          linkify(proto.name + '-' + method.name, method.name + 
          generateParamsString(method.params)) + ' - ' + method.summary;
      }).join('\n');
      output += '\n';
    });
  });

  output += '\n\n';

  files.forEach(function(file) {
    // Generate a section for each prototype
    file.contents.protos.forEach(function(proto) {
      output += '<a name="'+proto.name+'" />\n';
      
      output += '##' + proto.name + 
        (program.n ? '' : ' &bull; ' + linkify('top') + '\n\n') +
        'Location: ' + file.name + '\n\n' +
        proto.constructor.full + '\n\n' + 
        generateParamsTable(proto.constructor.params) + '\n\n';

      output += proto.methods.map(function(method) {
        return '<a name="' + proto.name + '-' + method.name+'">\n' +
          '###' + linkify(proto.name) + '#' + method.name + 
          generateParamsString(method.params) + '\n\n' +
          method.full;
      }).join('\n\n');
    });
  });

  return output;
}

function parseInput(buf) {
  var doxInput = dox.parseComments(buf, {raw: true});

  var functions = _.chain(doxInput)
    .filter(function(input) {
      return input.ctx && input.ctx.type === 'function';
    })
    .map(function(input) {
      return {
        name: input.ctx.name,
        params: getParams(input),
        summary: input.description.summary,
        full: input.description.full
      };
    })
    .value();

  var protos = _.chain(doxInput)
    .filter(function(input) {
      // Filter out module exports for initial proto definitions
      return input.ctx && input.ctx.receiver !== 'module' && input.ctx.type !== 'function';
    })
    .groupBy(function(o) {
      return o.ctx.constructor;
    })
    .value();

  protos = Object.keys(protos).map(function(constructor) {

    // Generate a nice method definition including a formatted param string
    var methods = protos[constructor].map(function(property){
      return {
        name: property.ctx.name,
        params: getParams(property),
        summary: property.description.summary,
        full: property.description.full
      }  
    });

    return {
      name: constructor,
      methods: methods
    }
  });

  // Find the functions which are actually constructors
  protos = _.map(protos, function(proto) {
    functions = _.filter(functions, function(fun) {
      if (fun.name == proto.name) {
        proto.constructor = fun;
        return false;
      }
    });
    return proto;
  });

  return {
    protos: protos,
    functions: functions
  };
}

function getParams(input) {
  return _.filter(input.tags, function(tag) {
    return tag.type === 'param';
  });
};

function generateParamsString(params){
  if (!params || params.length == 0) return '()';
  return _.reduce(params, function(memo, tag) {
       return memo + tag.types.join('|') + ' ' + tag.name + ', ';
    }, '(')
    .slice(0, -2) + ')';
};

function generateParamsTable(params){
  if (!params || params.length == 0) return '';
  return _.reduce(params, function(memo, tag) {
      return memo + '<tr><td>' + tag.name + '</td><td>' + tag.types.join('|') +
        '</td><td>'+tag.description+'</td></tr>';
    }, 'Params\n\n<table>') + '</table>';
};

function linkify(link, display){
  if (typeof(display) === 'undefined') {
    display = link;
  };
  return '[' + display + '](#' + link + ')'; 
};


var files = program.args;
var normalizedFiles = [];

if (files.length == 0) {
  console.error('Error: Input files required.')
  program.outputHelp();
  process.exit();
}

// Get a flat list of files, including those in directories
for (var i = files.length - 1; i >= 0; i--) {
  try {
    var stats = fs.statSync(files[i]);  
  } catch(e) {
    console.error('Error: ' + file[i] + ' not found.');
    program.outputHelp();
    process.exit();
  }
  
  if (stats.isDirectory()) {
    var dirFiles = fs.readdirSync(files[i]).map(function(file) {
      return path.join(files[i], file);
    });

    normalizedFiles = normalizedFiles.concat(dirFiles);
  } else {
    normalizedFiles = normalizedFiles.concat(files[i]);
  }
};

// Make sure javascripty
normalizedFiles = normalizedFiles.filter(function(file) {
  return file.indexOf('.js') == file.length - 3;
});

normalizedFiles = normalizedFiles.map(function(file) {
  var name = file,
    string = fs.readFileSync(name).toString();

  return {
    name: name,
    contents: parseInput(string)
  }
});

var output = generateOutput(normalizedFiles);

if (program.html) {
  process.stdout.write(md(output));
} else {
  process.stdout.write(output);
}