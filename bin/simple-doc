#!/usr/bin/env node

var path = require('path');

var fs = require('fs'),
  program = require('commander'),
  _ = require('lodash'),
  dox = require('dox'),
  md = require('github-flavored-markdown').parse,
  fs = require('fs');

program
  .option('-t, --title [title: Docs]', 'Title for your markdown document', 'Docs')
  .option('-n, --nolink [false]', 'Don\'t link back to the top of the document', false)
  .option('--html [false]', 'Output html nstead of markdown', false)
  .parse(process.argv)

function getParams(input) {
  return _.filter(input.tags, function(tag) {
    return tag.type === 'param';
  });
};

function generateParamsString(params){
  if (!params || params.length == 0) return '()';
  return _.reduce(params, function(memo, tag) {
       return memo + tag.types.join('|') + ' ' + tag.name + ', ';
    }, '(')
    .slice(0, -2) + ')';
};

function generateParamsTable(params){
  if (!params || params.length == 0) return '';
  return _.reduce(params, function(memo, tag) {
      return memo + '<tr><td>' + tag.name + '</td><td>' + tag.types.join('|') +
        '</td><td>'+tag.description+'</td></tr>';
    }, 'Params\n\n<table>') + '</table>';
};

function linkify(link, display){
  if (typeof(display) === 'undefined') {
    display = link;
  };
  return '[' + display + '](#' + link + ')'; 
};

var buf = '';
process.stdin.setEncoding('utf8');
process.stdin.on('data', function(chunk){ buf += chunk; });
process.stdin.on('end', function(){
  var doxInput = dox.parseComments(buf, {raw: true});

  var functions = _.chain(doxInput)
    .filter(function(input) {
      return input.ctx.type === 'function';
    })
    .map(function(input) {
      return {
        name: input.ctx.name,
        params: getParams(input),
        summary: input.description.summary,
        full: input.description.full
      };
    })
    .value();

  var protos = _.chain(doxInput)
    .filter(function(input) {
      // Filter out module exports for initial proto definitions
      return input.ctx.receiver !== 'module' && input.ctx.type !== 'function';
    })
    .groupBy(function(o) {
      return o.ctx.constructor;
    })
    .value();

  protos = Object.keys(protos).map(function(constructor) {

    // Generate a nice method definition including a formatted param string
    var methods = protos[constructor].map(function(property){
      return {
        name: property.ctx.name,
        params: getParams(property),
        summary: property.description.summary,
        full: property.description.full
      }  
    });

    return {
      name: constructor,
      methods: methods
    }
  });

  // Find the functions which are actually constructors
  protos = _.map(protos, function(proto) {
    functions = _.filter(functions, function(fun) {
      if (fun.name == proto.name) {
        proto.constructor = fun;
        return false;
      }
    });
    return proto;
  });

  // Generate an anchor at the top of the document
  var output = '<a name="top" />\n\n#' + program.title + '\n\n';

  // Generate a list of prototypes and methods attached to those prototypes
  protos.forEach(function(proto) {
    output += '* '+ linkify(proto.name) + '\n';
    output += proto.methods.map(function(method) {
      return '    * ' + 
        linkify(proto.name + '-' + method.name, method.name + 
        generateParamsString(method.params)) + ' - ' + method.summary;
    }).join('\n');
  });

  output += '\n\n';

  // Generate a section for each prototype
  protos.forEach(function(proto) {
    output += '<a name="'+proto.name+'" />\n';
    
    output += '##'+ proto.name + 
      (program.n ? '' : ' &bull; ' + linkify('top') + '\n\n') +
      '\n\n' + 
      proto.constructor.full + '\n\n' + 
      generateParamsTable(proto.constructor.params) + '\n\n';

    output += proto.methods.map(function(method) {
      return '<a name="' + proto.name + '-' + method.name+'">\n' +
        '###' + linkify(proto.name) + '#' + method.name + '\n\n' + 
        generateParamsTable(method.params) + '\n\n' +
        method.full;
    }).join('\n\n');
  })

  if (program.html) {
    process.stdout.write(md(output));  
  } else {
    process.stdout.write(output);
  };
  
}).resume();