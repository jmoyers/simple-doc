[
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "file",
        "description": "name of file to be read in"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Helper method for reading a file into the log parser directly. </p>\n\n<p>Assumes first line of the file is going to be a header, so skips it for parsing. Buffers input <br />until newline, then feeds each line into the parser. When its finished, it emits an end event. <br />Because parsing is synchronous, you can depend on parsing being complete.</p>",
      "summary": "<p>Helper method for reading a file into the log parser directly. </p>",
      "body": "<p>Assumes first line of the file is going to be a header, so skips it for parsing. Buffers input <br />until newline, then feeds each line into the parser. When its finished, it emits an end event. <br />Because parsing is synchronous, you can depend on parsing being complete.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Parser.prototype.readFile = function(file) {\n  var that = this;\n\n  new lazy(fs.createReadStream(file))\n    .lines\n    .skip(1)\n    .forEach(function(line){\n      that.write(line.toString());\n    })\n    .join(function(){\n      that.emit('end');\n    });\n}",
    "ctx": {
      "type": "method",
      "constructor": "Parser",
      "name": "readFile",
      "string": "Parser.prototype.readFile()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "line",
        "description": "a single line of formatted sococo log text"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Write log file lines to be parsed</p>\n\n<p>Conforming to the stream api, mostly so you can parse together data transform streams. This stream<br />expects lines in string format.</p>",
      "summary": "<p>Write log file lines to be parsed</p>",
      "body": "<p>Conforming to the stream api, mostly so you can parse together data transform streams. This stream<br />expects lines in string format.</p>"
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Parser.prototype.write = function(line) {\n  var that = this,\n    items = line.split(',');\n\n  if (items.length < 8) {\n    return;\n  }\n\n  var mess = items[8].replace(/\\n/g, '').replace(/\\r/g, '');\n\n  if (items.length > 9) {\n    for (var j = 9; j < items.length; j++) {\n      mess += ',' + items[j];\n    }\n  }\n\n  if (mess[0] == ' '){\n    mess = mess.substring(1);\n  }\n\n  var transportData = this.parseTransportData(mess);\n  mess = !~mess.indexOf('}}') ? mess : mess.split('}}')[1].replace(/^\\s+/,\"\");\n\n  var entry = {\n    cpuId: items[0].replace(/ /g, ''),\n    processId: items[1].replace(/ /g, ''),\n    threadId: items[2].replace(/ /g, ''),\n    diffTime: items[3].replace(/ /g, ''),\n    systemDate: items[4].replace(/ /g, ''),\n    systemTime: items[5].replace(/ /g, ''),\n    severity: items[6].replace(/ /g, ''),\n    facility: items[7].replace(/ /g, ''),\n    transportData: transportData,\n    message: mess\n  };\n\n  this.emit('data', entry);\n}",
    "ctx": {
      "type": "method",
      "constructor": "Parser",
      "name": "write",
      "string": "Parser.prototype.write()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "logMessage",
        "description": "one line of a sococo log"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Parse sococo transport data out of a log line</p>\n\n<p>We have a header on log messages that conforms roughly to a {{name:value;name:value}} format. This<br />method parses that data off raw log message and returns a javascript object.</p>",
      "summary": "<p>Parse sococo transport data out of a log line</p>",
      "body": "<p>We have a header on log messages that conforms roughly to a {{name:value;name:value}} format. This<br />method parses that data off raw log message and returns a javascript object.</p>"
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Parser.prototype.parseTransportData = function(logMessage) {\n  if (!~logMessage.indexOf('{{')) {\n    return false;\n  }\n\n  var data = logMessage.split('}}')[0].split('{{')[1];\n\n  data = data.split(';');\n\n  var transportData = {}\n\n  if (data[0] == 'r') {\n    transportData['direction'] = 'receiving';\n  } else if (data[0] == 's') {\n    transportData['direction'] = 'sending';\n  }\n\n  for (var i = 0; i < data.length; i++) {\n    if (data[i].indexOf('#=') != -1) {\n      transportData['packetNumber'] = data[i].split('=')[1];\n    }\n    if (data[i].indexOf('s=') != -1) {\n      transportData['session'] = data[i].split('=')[1];\n    }\n    if (data[i].indexOf('c=') != -1) {\n      transportData['channel'] = data[i].split('=')[1];\n    }\n    if (data[i].indexOf('t=') != -1) {\n      transportData['payloadType'] = data[i].split('=')[1];\n    }\n    if (data[i].indexOf('m=') != -1) {\n      transportData['mediaElementId'] = data[i].split('=')[1];\n    }\n  }\n\n  return transportData;\n}",
    "ctx": {
      "type": "method",
      "constructor": "Parser",
      "name": "parseTransportData",
      "string": "Parser.prototype.parseTransportData()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "name",
        "description": "description"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Parser: a class for parsing sococo log files and emitting structured data</p>\n\n<p>This conforms to the node Stream base class, and can be chained together with other stream filters<br />using the <code>.pipe()</code> method. This class expects data to be in line format rather than chunks of<br />data coming directly from the file. You can use readFile to pass in a file directly, and it will<br />convert into buffered lines for you.</p>\n\n<h2>Examples</h2>\n\n<p>var p = new Parser();<br />  p.on('data', function(data){<br />      console.log(data);<br />  });<br />  p.on('end', function(){<br />      console.log('parsing complete');<br />  })<br />  p.readFile('test-log.txt');</p>",
      "summary": "<p>Parser: a class for parsing sococo log files and emitting structured data</p>",
      "body": "<p>This conforms to the node Stream base class, and can be chained together with other stream filters<br />using the <code>.pipe()</code> method. This class expects data to be in line format rather than chunks of<br />data coming directly from the file. You can use readFile to pass in a file directly, and it will<br />convert into buffered lines for you.</p>\n\n<h2>Examples</h2>\n\n<p>var p = new Parser();<br />  p.on('data', function(data){<br />      console.log(data);<br />  });<br />  p.on('end', function(){<br />      console.log('parsing complete');<br />  })<br />  p.readFile('test-log.txt');</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "module.exports = Parser;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "Parser",
      "string": "module.exports"
    }
  }
]